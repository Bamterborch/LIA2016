\section{Results}\label{sec:results}
This section will present the results of the applied migration strategy. 

\subsection{Product comparison}

\begin{table}[] 
\centering
\caption{Comparison between most used configuration management systems a new model}
\label{table:comparison}
\begin{tabular}{l|l|l|l|}
\cline{2-4}
             	  	& Puppet       & Anisible                                                               & MGMT         \\ \hline
\multicolumn{1}{|l|}	{Introduced}   & 2005	    & 2012								     & 2015	    \\ \hline
\multicolumn{1}{|l|}	{Architecture} & Pull         & Push                                                                   & Distributed  \\ \hline
\multicolumn{1}{|l|}	{Client}       & Yes          & None                                                                   & Mash of agents  \\ \hline
\multicolumn{1}{|l|}	{TCP port}     & 8140         & 22                                                                     & 2379             \\ \hline
\multicolumn{1}{|l|}	{Language}     & Puppet DSL   & YAML                                                                   & Experimental DSL  \\ \hline
\multicolumn{1}{|l|}	{Processing}   & Random execution		& Sequential                                                            & parallel execution \\ \hline
\multicolumn{1}{|l|} 	{Event driven} & No           & No                                                                     & Yes              \\ \hline
\multicolumn{1}{|l|}	{OS support}   & \begin{tabular}[c]{@{}l@{}}Major Operating systems \\ that allow a puppet client\end{tabular} & \begin{tabular}[c]{@{}l@{}}Everything that \\ accepts SSH\end{tabular} & \begin{tabular}[c]{@{}l@{}}Major Operating \\ systems \end{tabular} \\ \hline 
\end{tabular}
\end{table}

As shown in table \ref{table:comparison} there are some different architectures for configuration management available. All with there own advantages and disadvantages. The products in the table are introduced years from each other. The trend went from pull based to push based systems where the latest approach uses a distributed system.

%Talk about consolidation of amount of lines of code
As seen in chapter \ref{sec:relatedwork} a lot of companies are migrating away from puppet because the systems tends to end up into spaghetti code \cite{movingawayfrompuppet} where the same result could be created by newer systems with less code. According to Ryan Lane \cite{movingawayfrompuppet} the puppet code was ten thousand lines where the same result was achieved by thousand lines of Ansible code. Using a CMS within a small company is not very usefull since the CMS also needs to be maintained by the system administrator (SA). Using a CMS allows an SA to fix system bugs like shellshock within a couple of minutes on all managed servers as shown in code snippet \ref{lst:shellshock}.

\subsection{Operational differences}
The benefits of each system is dictated by the chosen architecture. A push system like Ansible will connect to all of the systems that are a target for the playbook to see if the configuration matches the required configuration from the playbook. This make the architecture very easy to use, it has a low overhead and the only client side system requirement is the ability of an SSH connection into the client. But this architecture also knows a downside. When a Large environment has multiple playbooks and a specific playbook is not run systematically. Configuration changes can be made on local client system or application settings. Therefore not matching the rest of the servers with the same roll. The difference will only be corrected when the appropriate playbook is run from the Ansible server, it needs to be a setting that is regulated by the playbook as well. As for a pull based system the client checks in every 30 minutes (default for Puppet) and checks its configuration to the required configuration set by the master system. When changes are made to the system these changes will be corrected automatically. So unregistered changes will be overwritten as look as the configuration job regulates them. When changes are made to parts that are not regulated by the management system these changes will stay unnoticed and unchanged. The overhead of a pull based system can be a problem. Systems will check in every 30 minutes to look for changes. In large environments this could cause links getting fully used and solutions like voice over IP that demand low latency links could fail. Next to the differences between generic push and pull based systems Ansible and Puppet have there own restrictions. There is no way to tell Puppet what commands to execute first. When installing the Apache service and controlling the content of the html files published by Apache. The files could be created before Apache is installed. The installation of Apache will overwrite some of the files. So relations should be created within Puppet. These extra lines of code make Puppet a complex beast to manage. Where Ansible executes commands in the order as they are written in the playbook, in case of a failure The entire script is exited. When running the script again it will start from the first step. Trying to install Apache, where it was already installed in the first execution of the playbook. This will take extra time. It makes it easy to troubleshoot problems. When Puppet runs into an error, the next command from the job will be executed and after the entire job the commands that failed will be reported. Looking into complexity between puppet and Ansible, Ansible is a lot easier to learn and to implement into a new environment.

\subsection{Migration results}
When migrating between two CMS's, both CMS's need to talk to each other. Systems need to be removed from and added to configuration files. Therefore accounts that have the correct privileges need to be present at both environments. When creating a Puppet job that will run an Ansible playbook. User interaction is not allowed for running the playbook. Ansible uses certificates to login to the clients. So when the private key is protected by a password every playbook requires the password to be entered. Certificates is one of the methods most management solution use to connect to there clients. When new hosts are added to the management machines some user action is often required for the acceptance of certificates. For Puppet the way to allow all certificates is explained in section \ref{sec:methodology}. When the management server is ready to manage new clients. The proposed method in this report can be run during production hours, services on machines will not be interrupted in any way. This is because the management system the company is migrating away from will tell the clients to start communicating with a different management system. The jobs on the new management machines are executed by the old replaced system. The described method is also able to migrate a large number of machines at once instead of migrating server by server which will not scale in large environments. 

