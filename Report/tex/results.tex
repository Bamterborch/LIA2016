\section{Results}\label{sec:results}
During this project we have performed an in place migration from Puppet to Ansible and vice versa with a single CMS managing the whole infrastructure as a result.

\subsection{Product comparison}
%Discuss operational advantages and implications (Table)

%Talk about consolidation of amount of lines of code
As seen in chapter \ref{sec:relatedwork} a lot of companies are migrating away from puppet because the systems tends to end up into spaghetti code \cite{movingawayfrompuppet} where the same result could be created by newer systems with less code. According to Ryan Lane \cite{movingawayfrompuppet} the puppet code was ten thousand lines where the same result was achieved by thousand lines of Ansible code. Using a CMS within a small company is not very usefull since the CMS also needs to be maintained by the system administrator (SA). Using a CMS allows an SA to fix system bugs like shellshock within a couple of minutes on all managed servers as shown in code snippet \ref{lst:shellshock}.

\subsection{Operational differences}
The benefits of each system is dictated by the chosen architecture. A push system like Ansible will connect to all of the systems that are a target for the playbook to see if the configuration matches the required configuration from the playbook. This make the architecture very easy to use, it has a low overhead and the only client side system requirement is the ability of an SSH connection into the client. But this architecture also knows a downside. When a Large environment has multiple playbooks and a specific playbook is not run systematically. Configuration changes can be made on local client system or application settings. Therefore not matching the rest of the servers with the same roll. The difference will only be corrected when the appropriate playbook is run from the Ansible server, it needs to be a setting that is regulated by the playbook as well. As for a pull based system the client checks in every 30 minutes (default for Puppet) and checks its configuration to the required configuration set by the master system. When changes are made to the system these changes will be corrected automatically. So unregistered changes will be overwritten as look as the configuration job regulates them. When changes are made to parts that are not regulated by the management system these changes will stay unnoticed and unchanged. The overhead of a pull based system can be a problem. Systems will check in every 30 minutes to look for changes. In large environments this could cause links getting fully used and solutions like voice over IP that demand low latency links could fail. Next to the differences between generic push and pull based systems Ansible and Puppet have there own restrictions. There is no way to tell Puppet what commands to execute first. When installing the Apache service and controlling the content of the html files published by Apache. The files could be created before Apache is installed. The installation of Apache will overwrite some of the files. So relations should be created within Puppet. These extra lines of code make Puppet a complex beast to manage. Where Ansible executes commands in the order as they are written in the playbook, in case of a failure The entire script is exited. When running the script again it will start from the first step. Trying to install Apache, where it was already installed in the first execution of the playbook. This will take extra time. It makes it easy to troubleshoot problems. When Puppet runs into an error, the next command from the job will be executed and after the entire job the commands that failed will be reported. Looking into complexity between puppet and Ansible, Ansible is a lot easier to learn and to implement into a new environment.

\subsection{Migration results}
% During the migration we have noticed [...] 

\subsection{Adviced strategy}
\cite{tecosystems_2013}
% Why is our migration strategy better than migrating directly with Ansible?
