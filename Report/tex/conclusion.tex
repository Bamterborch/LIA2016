\section{Conclusion}\label{sec:conclusion}
Migration between different configuration management systems is a valid use case for large installations. Puppet origins from 2005 and Ansible origins from 2012. The architecture of these two systems is totally different but Puppet and Ansible are the most used CMS's used. As seen in chapter \ref{ch:relatedwork} a lot of companies are migrating away from puppet because the systems tends to end up into spaghetti code \cite{movingawayfrompuppet} where the same result could be created by newer systems with less code. According to Ryan Lane \cite{movingawayfrompuppet} the puppet code was ten thousand lines where the same result was achieved by 1000 lines of Ansible code. Using a CMS within a small company is not usefull since the CMS also needs to be maintained by the system administrator (SA). Using a CMS allows an SA to fix system bugs like shellshock within a couple of minutes on all managed servers as shown in code snippet \ref{lst:shellshock}.

For the migration between systems with a different architecture as the example in this paper. Migrating from Puppet to Ansible needs to be triggered from the puppet server. Therefore jobs for the Ansible server, adding hosts to the hosts file and running a specific playbook needs to be initialized by the Puppet master, So the Puppet client need to be installed on the Ansible server. To be able to execute this, the privileged user needs to be present on both CMS's. Ansible uses its certificate to connect to remote clients. When a password is used to generate the private key this password needs to be entered when a playbook is executed. Therefore a private key without password should be used during migration.   


% ups and downs of puppet and ansible
% Puppet runs task out of order. so index.html could be written before apache is installed and therefore apache will overwrite
% ansible only runs when playbook is fired
% Ansible stops entire sequence when one job failes . puppet continues. 
% ansible is in the kern simpler

\subsection{Future Work}\label{subsec:futurework}
This report primarily focuses on managing generic virtual machine instances with Puppet and Ansible and does not take Docker containerization in consideration. Deploying Docker containers on a large scale is currently primarily being done via Dockerfiles, which contain a sequence of pre-defined commands in order to deploy a service with a given configuration. Problems occur when the services to be deployed become overly complex and require a large set of commands. At that point they require relatively static and unmanageable Dockerfiles. Configuration management tools like the ones discussed in this report are currently looking into supporting fine-grained configuration management features for various types of container platforms. However, as such features become available the line between 'true' orchestration tools like Kubernetes \cite{kubernetes_2016} become less obvious. It would be interesting to see how orchestration tools at this point in time relate to configuration management tools and whether a clear distinction can be made in the near future.

Although we don't focus on \texttt{mgmt} in detail in this report, it is undeniably an interesting development. As this new tool is still in an experimental phase, it does not have a definitive Domain Specific Language in place yet. This means that a migration strategy to a distributed model is currently out of scope. However, when the development of \texttt{mgmt} takes on a more solid form, it would be interesting to see how a migration from Puppet to \texttt{mgmt} would play out. James \cite{frank_2016} provides a starting point for transpiling Puppet modules to \texttt{mgmt} resource graphs by using a series of complex regular expressions. However, further investigation on this topic is required.
