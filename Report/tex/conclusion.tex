\section{Conclusion}\label{sec:conclusion}
Migration between different configuration management systems is a valid use case for large installations. Puppet origins from 2005 and Ansible origins from 2012. Puppet and Ansible are the most used CMS's and have totally different architectures and use cases. As seen in chapter \ref{sec:relatedwork} a lot of companies are migrating away from puppet because the systems tends to end up into spaghetti code \cite{movingawayfrompuppet} where the same result could be created by newer systems with less code. According to Ryan Lane \cite{movingawayfrompuppet} the puppet code was ten thousand lines where the same result was achieved by thousand lines of Ansible code. Using a CMS within a small company is not very usefull since the CMS also needs to be maintained by the system administrator (SA). Using a CMS allows an SA to fix system bugs like shellshock within a couple of minutes on all managed servers as shown in code snippet \ref{lst:shellshock}.

For the migration between systems with a different architecture as the example in this paper. Migrating from Puppet to Ansible needs to be triggered from the puppet server. Therefore jobs for the Ansible server, adding hosts to the hosts file and running a specific playbook needs to be initialized by the Puppet master, So the Puppet client need to be installed on the Ansible server. To be able to execute this, the privileged user needs to be present on both CMS's. Ansible uses its certificate to connect to remote clients. When a password is used to generate the private key this password needs to be entered when a playbook is executed. Therefore a private key without password should be used during migration.   

\subsection{Differences}\label{subsec:differences}
The benefits of each system is dictated by the chosen architecture. A push system like Ansible will connect to all of the systems that are a target for the playbook to see if the configuration matches the required configuration from the playbook. This make the architecture very easy to use, it has a low overhead and the only client side system requirement is the ability of an SSH connection into the client. But this architecture also knows a downside. When a Large environment has multiple playbooks and a specific playbook is not run systematically. Configuration changes can be made on local client system or application settings. Therefore not matching the rest of the servers with the same roll. The difference will only be corrected when the appropriate playbook is run from the Ansible server, it needs to be a setting that is regulated by the playbook as well. As for a pull based system the client checks in every 30 minutes (default for Puppet) and checks its configuration to the required configuration set by the master system. When changes are made to the system these changes will be corrected automatically. So unregistered changes will be overwritten as look as the configuration job regulates them. When changes are made to parts that are not regulated by the management system these changes will stay unnoticed and unchanged. The overhead of a pull based system can be a problem. Systems will check in every 30 minutes to look for changes. In large environments this could cause links getting fully used and solutions like voice over IP that demand low latency links could fail. Next to the differences between generic push and pull based systems Ansible and Puppet have there own restrictions. There is no way to tell Puppet what commands to execute first. When installing the Apache service and controlling the content of the html files published by Apache. The files could be created before Apache is installed. The installation of Apache will overwrite some of the files. So relations should be created within Puppet. These extra lines of code make Puppet a complex beast to manage. Where Ansible executes commands in the order as they are written in the playbook, in case of a failure The entire script is exited. When running the script again it will start from the first step. Trying to install Apache, where it was already installed in the first execution of the playbook. This will take extra time. It makes it easy to troubleshoot problems. When Puppet runs into an error, the next command from the job will be executed and after the entire job the commands that failed will be reported. Looking into complexity between puppet and Ansible, Ansible is a lot easier to learn and to implement into a new environment.  


\subsection{Future Work}\label{subsec:futurework}
This report primarily focuses on managing generic virtual machine instances with Puppet and Ansible and does not take Docker containerization in consideration. Deploying Docker containers on a large scale is currently primarily being done via Dockerfiles, which contain a sequence of pre-defined commands in order to deploy a service with a given configuration. Problems occur when the services to be deployed become overly complex and require a large set of commands. At that point they require relatively static and unmanageable Dockerfiles. Configuration management tools like the ones discussed in this report are currently looking into supporting fine-grained configuration management features for various types of container platforms. However, as such features become available the line between 'true' orchestration tools like Kubernetes \cite{kubernetes_2016} become less obvious. It would be interesting to see how orchestration tools at this point in time relate to configuration management tools and whether a clear distinction can be made in the near future.

Although we don't focus on \texttt{mgmt} in detail in this report, it is undeniably an interesting development. As this new tool is still in an experimental phase, it does not have a definitive Domain Specific Language in place yet. This means that a migration strategy to a distributed model is currently out of scope. However, when the development of \texttt{mgmt} takes on a more solid form, it would be interesting to see how a migration from Puppet to \texttt{mgmt} would play out. James \cite{frank_2016} provides a starting point for transpiling Puppet modules to \texttt{mgmt} resource graphs by using a series of complex regular expressions. However, further investigation on this topic is required.
