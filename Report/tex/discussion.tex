\section{Discussion}\label{sec:discussion}
During this project we have performed an in place migration from Puppet to Ansible and vice versa with a single CMS managing the whole infrastructure as a result. Arguably however, there are use cases in which both systems can coexist with varying purposes in mind. Villamil \cite{villamil_2014} for example argues that Ansible is more suitable for server deployments whereas Puppet excels at defining an end state for a system. From a technical standpoint, such a 'migration trajectory' is significantly easier as it omits the automated removal step from the migration strategy as portrayed in section \ref{sec:methodology}.

Furthermore, the migration strategy as presented in this report is not a 'one size fits all' solution. One could argue for example that when a large amount of resources are available, an environment could be migrated by spinning up copies of existing servers with the new configuration management tool in place. Especially when services are deployed behind a loadbalancer, servers could be deployed in parallel with existing servers. Legacy machines could then be gradually decommissioned. However, this would be feasible when an excess amount of resources are available and when the total amount of servers to be migrated is manageable, as otherwise a gradual migration strategy would require a disproportional amount of time. Additionally with the move to DevOps, some companies might employ an immutability concept when deploying servers meaning that any change to a server configuration would require the base image file to be redefined. Subsequently, the server would be decommissioned and redeployed with a new configuration. 
\\\\
Regarding \texttt{mgmt}, this new configuration management system shows significant improvements over traditional tools. However, the scalability of a distributed model has yet to be proven in practice. For example, the test scenarios in this report only take small environments into consideration, monitoring only a handful of files or packages at a time. We imagine that when environments grow and dependencies between installed packages and files become more complex it will take longer for a system to be put in a converged state again. Additionally, continuously monitoring all events can potentially become a performance hit when environments grow. To prevent scalability issues, \texttt{mgmt} has a fail-safe built in which allows the system to only monitor periodically by setting a \texttt{--converged-timeout} parameter. However, by using this function \texttt{mgmt} largely behaves like a traditional configuration management system again.  

Lastly, we have seen that migrating from Puppet to Ansible made the language constructs for defining a state easier due to Ansible's adoption of YAML. As \texttt{mgmt} uses similar language constructs, migrating Ansible playbooks to \texttt{mgmt} resource graphs would be relatively easy. Still, as a closing remark we want to stress that a migration between configuration management systems is a delicate task in which specific configuration changes have to be made in a specific order, regardless of the target CMS. These changes  heavily depend on the architectural model employed by the tool and the defining language in place. Therefore it is not advisable to envision the migration steps as presented in this report as a generic migration model. 