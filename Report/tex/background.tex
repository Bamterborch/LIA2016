\section{Background}\label{sec:background}
As the line between system management and system orchestration is becoming thinner, configuration management tools are likely to be used for some orchestration purposes. Additionally, all configuration management systems (CMS) are using either a push or a pull system to inform clients in case of updates. Lastly, \texttt{mgmt} is a new system which challenges the architectural model of established configuration management tools. This section presents a brief comparison of the selected configuration management tools and the distributed \texttt{mgmt}.


\subsection{Orchestration and configuration management}\label{subsec:orchestration}
In this report we repeatedly discuss configuration management. As this term carries a somewhat ambiguous definition, we settle on the definition as presented by Lexis \cite{}. He defines configuration management as ``the techniques and policies to track hardware, infrastructure and software, and the configuration thereof''. During the course of this report we will use this definition exclusively.


\subsection{Differences between Push and Pull based management systems}\label{subsec:pushpull}
Puppet and Chef are pull based CMS's. A clients needs to be installed on the managed machine. This clients checks in at the server every x minutes. For puppet the default x time is 30 minutes. So every 30 minutes the configuration as it should be according to puppet is compared to the current configuration of the server. The puppet configuration can make sure a specific version of apache is installed or if a website contains a certain line of text. When the configuration differs from the configuration set in the Puppet configuration it will be changed immediately. Where Ansible and Salt use the push technique to send commands to a managed machine. Ansible uses playbook which hold the command set for specific server and it contains the destinations for the command set. The management server starts communication over SSH to the management machines and delivers and runs a python script on the client. So Python is a prerequisite for Ansible. The Python script is removed right after it is executed. This way of configuring servers is on demand. But as Puppet it is able to check for specific software versions or check file content and change it if needed. When a configuration differs from the configuration in the playbook. The client will be changed when the playbook is run by an administrator. So when a playbook is not run, the configuration could differ from the intended configuration for a long time. 

When a CMS only needs SSH to remote configure a machine, the scale of systems it could manage is a lot bigger than a client based system. If the system to manage has a closed operating system it cant be managed by a pull based CMS. All large networking brands make sure there operating systems (OS) are able to keep running for years without interruption. To make sure the system stays up the OS is closed down making sure no third party applications are able to disrupt the system. Push based systems only rely on a SSH connection. Ansible is capable of executing the python script on the server, therefore the requirement of python on the managed server is no longer there. This makes it possible to manage closed source network operating systems like Juniper or Cisco devices run. 

A router or switch could be set up with the necessary basics to make sure it can be placed at the designated location and is accessible over the network by SSH. Ansible can be set up to do the rest of the configuration. Running a playbook that will generate a base configuration for all the machines with the same class and check the running configuration to see if it matches. If it doesn't match. Ansible will change it. Next to configuration changes, depending on the brand of equipment, Ansible is capable of performing a code upgrade on network devices. Some of the new devices offer nonstop service upgrades \cite{NSSU}\cite{ISSU}, what actually means upgrading the system during office hours without any downtime (when everything is configured in a proper way and all requirements are matched). When the installed base of a specific brand and type is big enough automation of configuration or code changes have as much advantages on network devices as it has on server configuration.  

\subsection{Comparison between current systems and the new distributed MGMT system}\label{subsec:distributedmgmt}
As previously alluded to, a relatively new configuration management tool on the horizon is \texttt{mgmt}. \texttt{Mgmt} is a 'prototype next generation configuration management tool' by Shubin \cite{shubin2016}, which focuses on \textit{parallelization}, \textit{event driven changes} and most notably, a \textit{distributed architecture} \footnote{The source code for \texttt{mgmt} is available on GitHub: \url{https://github.com/purpleidea/mgmt/}}. The main innovation in \texttt{mgmt} is the distributed topology of the system. As discussed in section \ref{subsec:pushpull}, traditional tools like Puppet and Chef commonly run in a client-server topology. Naturally, as all code is placed in a central location, scalability and performance issues occur, especially when the amount of clients increases. Additionally, Shubin argues that using a client-server model reduces the configuration management tool to a single failure domain. Clustering of the master server could alleviate this problem, however, this would deteriorate the simplicity of a centralized system. Ansible on the other hand uses an orchestration model in which a push model is used.
 
However, providing the option for parallel execution introduces room for errors as well. In a simple example, running two package installations with \texttt{apt} in parallel would fail due to a global lock on \texttt{dpkg}. Similarly, dependencies between applications and libraries would. \texttt{mgmt} deals with this by batching (or grouping) all blocking operations and putting them in a sequential order. 

The main advantage which \texttt{mgmt} poses is that a migration between the tools could potentially be fairly easy. Converting Puppet modules to \texttt{mgmt} graphs is a straight forward process as displayed by ffrank \cite{}. However, due to the fact that \texttt{mgmt} still uses an experimental DSL, conversions at this point are mood. 


In the setup for our experiment, the modules have direct dependencies. However, in a real world scenario it isn't uncommon for a company to have multiple disconnected modules without inter-dependencies run simultaneously. 
