As previously alluded to, a relatively new configuration management tool on the horizon is \texttt{mgmt}. \texttt{Mgmt} is a prototype next generation configuration management tool by Shubin \cite{shubin2016}, which focuses on \textit{parallelization}, \textit{event driven changes} and most notably, a \textit{distributed architecture} \footnote{The source code for \texttt{mgmt} is available on GitHub: \url{https://github.com/purpleidea/mgmt/}}. The main innovation in \texttt{mgmt} is the distributed topology of the system. As discussed in section \ref{subsec:pushpull}, traditional tools like Puppet and Chef commonly run in a client-server topology. Naturally, as all code is placed in a central location, scalability and performance issues occur, especially when the amount of clients increases. Additionally, Shubin argues that using a client-server model reduces the configuration management tool to a single failure domain. Clustering of the master server could alleviate this problem, however, this would deteriorate the simplicity of a centralized system. Ansible on the other hand uses an orchestration model in which a push model is used.
 
However, providing the option for parallel execution introduces room for errors as well. In a simple example, running two package installations with \texttt{apt} in parallel would fail due to a global lock on \texttt{dpkg}. Similarly, dependencies between applications and libraries would. \texttt{mgmt} deals with this by batching (or grouping) all blocking operations and putting them in a sequential order. 

The main advantage which \texttt{mgmt} poses is that a migration between the tools could potentially be fairly easy. Converting Puppet modules to \texttt{mgmt} graphs is a straight forward process as displayed by ffrank \cite{}. However, due to the fact that \texttt{mgmt} still uses an experimental DSL, conversions at this point are mood. 


In the setup for our experiment, the modules have direct dependencies. However, in a real world scenario it isn't uncommon for a company to have multiple disconnected modules without inter-dependencies run simultaneously. 
