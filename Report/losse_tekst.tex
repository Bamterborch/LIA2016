Puppet is an open-source IT automation tool. The Puppet Domain Specific Language (DSL) is a Ruby-based coding language that provides a precise and adaptable way to describe a desired state for each machine in your infrastructure. Once you've described a desired state, Puppet does the work to bring your systems in line and keep them there.

The appeal of Puppet is that it allows you to describe all the details of a configuration in a way that abstracts away from operating system specifics, then manage those configurations on as many machines as you like.

In Puppet, a class is simply a named block of Puppet code that defines a set of associated system resources. A class might install a package, customize an associated configuration file for that package, and start a service provided by that package.

By default, the Puppet agent daemon runs in the background on all nodes you manage with Puppet. Every 30 minutes, the Puppet agent daemon requests a catalog from the Puppet master. The Puppet master parses all the classes applied to that node, builds the catalog to describe how the node is supposed to be configured, and returns this catalog to the node's Puppet agent. The agent then applies any changes necessary to bring the node into the line with the state described by the catalog.

Taking common tasks and abstracting away the complexities and pitfalls doesn't just make those tasks themselves easier, it gives you the stable, repeatable, and testable foundation you need to build something new. 

The block of code that describes a resource is called a resource declaration. These resource declarations are written in Puppet code, a Domain Specific Language (DSL) based on Ruby. For Puppet, this foundation is a system called the resource abstraction layer. Puppet interprets any aspect of your system configuration you want to manage (users, files, services, and packages, to give some common examples) as a unit called a resource. Puppet knows how to translate back and forth between the resource syntax and the 'native' tools of the system it's running on.

Instead of defining a process or set of commands, Puppet code describes (or declares) only the desired end state. With this desired state described, Puppet relies on built-in providers to handle implementation. A resource declaration will match the following pattern:

type {'title': # Resource titles are unique, the resource type comes from a predefined list by Puppet
    attribute => 'value', # General attribute-value pairs. 
}

I would say that Ansible has grown significantly in MINDSHARE, although I would hesitate to believe in MARKET SHARE.

Chef/Puppet have been in heavy use in the enterprise for some time and I think Ansible has captured the buzz recently, so it may seem as though it is growing probably faster than it is. Honestly, there are reasons to use both (in fact, we "might" talk about some of them when we launch our Ansible course on October 5th - just sayin'). 

At its simplest, a manifest is nothing more than some puppet code saved to a file with the .pp extension
In Puppet's DSL a class is a named block of Puppet code. The class is the next level of abstraction above a resource. A class declares a set of resources related to a single system component. Class parameters allow you to adapt a class to suit your needs. 

Declaring a class multiple times could give Puppet conflicting instructions for how to manage resources on a system.

A class is a collection of related resources and other classes which, once defined, can be declared as a single unit. Puppet classes are also singleton, which means that unlike classes in object oriented programming, a Puppet class can only be declared a single time on a given node.

A manifest is a file containing Puppet code, and appended with the .pp extension. In this quest, we used manifests in the ./manifests directory each to define a single class, and used a corresponding test manifest in the ./examples directory to declare each of those classes.

You may have noticed that the classes you wrote for cowsay and fortune were both prepended by cowsayings::. When you declare a class, this scope syntax tells Puppet where to find that class; in this case, it's in the cowsayings module.

For the main class of a module, things are a little different. The main class shares the name of the module itself.

In short, a Puppet module is a self-contained bundle of all the Puppet code and other data needed to manage some aspect of your configuration.

Defining all resources in a single class would hardly be an improvement of a previous scenario. Code re-usability would be limited and repeatability would be non-existent. Modularity is required. Because Puppet uses a modular structure, a service-oriented architecture becomes easier to realize. Previously created modules can be used again. And because these modules are separate and self-contained, they're much easier to test, maintain, and share than a collection of one-off solutions.

Classes can be defined but also require an 'include' declaration in the manifest. This way the code gets loaded. 

